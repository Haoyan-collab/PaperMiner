# 开发经验教训

记录开发中的关键错误和解决方案，持续更新。

---

## 数据同步与状态管理

**问题** | 删除高亮功能 - 创建时用临时ID `-1`，数据库返回真实ID后未更新DOM和JS数组，导致无法删除

**教训**
- 数据存在多处时（DOM、内存、数据库），必须同步更新所有位置
- 乐观更新后必须实现确认回调，更新临时数据为真实数据
- 设计完整流程：创建临时状态 → 持久化 → 回调确认 → 更新所有副本

**关键点**
- 列出数据存储的所有位置
- 异步操作要有完整生命周期：请求 → 确认 → 更新
- 临时数据必须有转换为正式数据的明确路径

---

## 事件处理与时序冲突

**问题** | 双击高亮显示删除菜单时闪现即消失 - `dblclick`触发多个基础事件，全局`mousedown`监听器立即隐藏菜单

**教训**
- 复合事件会触发多个基础事件（如`dblclick`触发两次`click`）
- 全局监听器与局部操作可能冲突
- 使用时间窗口保护：设置标志位+setTimeout防止立即关闭

**关键点**
- 理解事件触发顺序和冒泡机制
- 显示UI后设置短暂"保护期"（100-200ms）防止其他事件干扰
- 考虑使用`stopPropagation()`阻止冒泡

---

## 异步资源加载

**问题** | 在PDF.js的`textLayer`未加载完成时渲染高亮，报"Text layer not found"错误

**教训**
- 永远不要假设DOM元素已就绪，即使收到"ready"事件
- 第三方库的内部元素可能延迟加载
- 实现重试机制：检查元素 → 不存在则等待100ms后重试 → 设置最大重试次数

**关键点**
- 操作前检查元素是否存在
- 失败时重试，但要设置上限防止无限循环
- 优雅降级：资源加载失败不应导致整个功能崩溃

---

## 浏览器内核与多线程隔离 (Web Worker)

**问题** | PDF.js报错`hashOriginal.toHex is not a function`，在Python层 (QWebEngineScript) 注入Polyfill修复无效

**教训**
- Web Worker是隔离的：Worker线程有独立内存和JS环境，不共享主线程的window对象和DOM
- 注入局限性：Python的`runJavaScript`或`QWebEngineScript`只能注入主线程，无法穿透到Worker线程
- 报错源头：如果报错发生在Worker内部（如PDF解析、哈希计算），主线程的补丁不可见

**关键点**
- 判断报错位置：检查堆栈，确定是UI逻辑还是Worker逻辑（如`pdf.worker.mjs`）
- 物理修改源码：解决Worker兼容性的最稳妥方案是直接修改`.js/.mjs`源文件，Worker启动时会读取文件使补丁生效
- 运行时 vs 静态：运行时注入无法跨线程隔离；静态文件修改可覆盖所有场景

---

## 调试策略

**经验** | 详细日志大幅提升调试效率

**关键点**
- 记录关键变量值、操作结果、元素数量
- 记录状态转换（如临时ID → 真实ID）
- 区分失败原因，不只说"失败"而是"为什么失败"
- 使用不同日志级别：info/warn/error

---

## 开发检查清单

新功能开发前过一遍：

1. **数据流** - 数据存储在哪？如何流动？所有副本同步更新了吗？
2. **异步操作** - 哪些是异步的？如何确认完成？失败如何处理？
3. **事件处理** - 会触发哪些事件？是否冲突？需要时序保护吗？
4. **依赖关系** - 依赖哪些资源？如何验证已加载？
5. **线程模型** - 代码运行在主线程还是Worker？外部注入能触达吗？
6. **完整性** - CRUD都实现了吗？异常流程考虑了吗？日志够吗？

---

## 新问题模板

```markdown
## 问题类别标题

**问题** | 简述问题和现象

**教训**
- 核心教训1
- 核心教训2

**关键点**
- 具体实践要点
- 检查项或解决方案
```
